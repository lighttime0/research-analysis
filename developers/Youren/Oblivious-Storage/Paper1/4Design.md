## Design
### Basic system architecture
在上一个章节中我们看到我们已经可以简单的基于Intel SGX构建一个DHT的存储系统，但是这样的系统无法防止流量分析和一个active 的攻击者。

前文已经说到，对于每个用户请求，机器之间的通信每次都使用不同的同步秘钥，因此攻击者无法从密文中推断出信息。但是攻击者还是可能从数据包的大小得出数据包之间的关系并进行追踪，找到用户请求发往的机器。因此我们将Object分为固定大小的chunk，保证集群中所有的通信都是通过同样大小的数据包发送。大小不足的数据包则进行padding后再加密。

为了追踪磁盘上的数据，我们对每个Object维护一个Index。所有的Object的Index 组成一个列表。一个Index包括Object对应的每个chunk的MAC值和对应chunk的存储位置，以及加密秘钥。这些加密秘钥是在存储文件时随机生成的。

为了应对真实世界中时常发生的crash等，系统中需要部署一些crash恢复机制：将Indexs使用Sealing  key存储在持久化存储中，当机器crash重启后，从磁盘中读取Indexs并标记为不安全，不安全的Index可以通过其他的机器验证。这不是这篇论文主要讨论的。

### Split key and value
作为一个Cloud Storage，通常都是提供public service。这种情况下Client是不可信的，其可以构造自己的请求，知道自己的data access pattern。
因此一种可能攻击方式是，攻击者可以统计整个集群中每个磁盘块的访问频率，找到最符合自己访问频率的磁盘块。 这种攻击的原因在于Data center 内部的access pattern暴露给了攻击者。一个简单的隐藏access pattern的方法是每次都访问不同的位置。
在传统的Object storage系统中，每一次的修改都是写在一个全新的位置。但是每一次读请求都访问一样的位置。因此，我们需要将读请求和写请求统一为Access，并且每一次Access 都需要重新写在一个新的位置。

因为攻击者可以小范围的恶意攻击集群，所以我们每次访问的位置需要时跨机器的 —— 即每次访问同一个文件都访问不同的机器。但是在DHT中，如果一个文件每次都存储在不同的位置，如何找到这个最新的位置呢？
我们将一个文件的Key和value的存储位置分开，key还是按照原来的算法去寻找，但是value我们每次随机的在DHT中生成一个位置并存储下来，这个位置存在原来的Mk的Index中。
当一个用户请求到达集群中时，负责的机器首先通过key找到对应的机器Mk，并将该请求发送给Mk。Mk根据Key找到Index，并且从Index中读取对应的位置Mv，执行该请求。当Mv将请求结果返回之后，Mk随机生成一个新的位置Mv‘，并将最新的value发给Mv’。待Mv’存储完毕后，再将删除请求发送Mv。

当有两个或多个请求同时到达Mk时，我们可以进行一定的加速处理。

我们这样做并没有保护存储Index的Server—— 在DHT系统中其位置固定，因此无法保护。尽管一个机器对Index 的修改也许不需要存在磁盘上，但是如果有一个hot的object，那么该Index server 的网络流量会明显大于其他的机器。所以我们需要特别的手段来recover 一个crash的index。
我们采用的是Gossip 协议维护分布式集群，因此一个机器crash之后整个集群都会被通知到。每个机器在存储数据时，都在安全部分存储数据对应的key以及MAC值。一旦集群中有机器crash后并重新启动，所有的机器检查自己的存储数据，将该crash的机器所负责的key的数据的mac发回给该机器。由该机器进行检查。如果该机器crash并无法再启动，集群中的机器将数据全部发回给key对应的新的机器。
因为数据的存储位置是随机选定的，因此一个机器crash后，整个集群中的机器都需要将自己的MAC发回给该机器，攻击者无法确定哪个机器是自己想要的文件。

另外，我们需要对value采用不同的DHT位置，即一个机器在集群中拥有两个位置：一个是index的位置，另一个是value对应的位置。因为Index的位置会暴露，因此攻击者可以推断出index 对应的DHT的排列顺序。为了避免storage 中的replic之间的关系暴露，因此我们需要为storage使用另一个DHT表。

这样做会带来明显的代价，每一个用户请求需要额外的4次加密。但是我们会看到，和存储速度相比，加密所带来的额外的开销并不是系统的瓶颈。

### One layer Mix Network
我们通过随机的存储来隐藏文件的位置，但是我们知道，攻击者可以小范围的Dos或者恶意的延迟网络。因此我们需要让用户的每一个请求都真正的卷入所有的机器来执行。
考虑下面这种攻击方式：攻击者知道对应文件的Index server，因此当用户的请求R进入到Index server处理时，攻击者都是可以监控到的。假设用户请求进入的时间为T0，返回用户请求的时间为Ti。攻击者对T0 到T1之间的请求编上号，并按照编号发送。如index server 在T0到Ti之间发给机器M0至Mj的数据包编号为R0
到Rj，攻击者将R0到Rj的数据包按照0ms到jms的延迟发送出去，并假定这些数据包的返回时间为Tk-Tm。则返回时间靠近Ti的数据包可能是由攻击者感兴趣的机器发回的。这样攻击者就缩小了攻击范围。
同样的，假设用户请求R到达Index server Mi后，根据上一节可知这不是我们保护的信息，攻击者pendding所有的进入该Mi的数据包，一个一个送给安全部分。如果某一个数据包给安全部分后，用户请求得到了返回，则可以认为这个机器是最新的负责该用户请求的机器。
以上的攻击是可能的，因为一小个group的机器出现网络问题是可能的。
为了解决这个问题，我们采用单层的mix network，index server在向对应的value server发送请求时，不会直接将请求发送给对方，而是随机的选择一个机器，交给这个机器代为转发。而value server 在返回结果时，也需要找一个机器代为转发。

通过这样做一方面攻击者无法通过单独监控index server找到负责存储的机器，另一方面我们在处理每一个请求的时候都将所有的机器involve进来了，让攻击者无法通过dos少部分机器来找到目标。

假设机器中一共有n台机器，安全部分每次batch m个请求，通过一次转发，集群中一共有m\*m个请求。

### Virtual Node
virtual node是由[dynamo]提出的，用于在集群中load-balance。我们用virtual node除了load-balance, 还可以避免攻击者crash一台机器，在rebalance的时候，找到位置相邻的机器。
\图片
有了virtual node之后，每个物理节点的failure都会导致大量的物理节点参与进rebalance中。
