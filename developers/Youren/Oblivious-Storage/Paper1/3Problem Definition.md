## Problem Definiation

###Execution Model(What's this system for)
我们采用DHT的方式组织整个系统，DHT中每个机器都是对等的，同时DHT的系统可以很好的横向拓展(horizontal scaling)。为了能够检测到集群中机器的crash，我们使用gossip 协议。
####Harden System with Intel SGX
如前所述，Intel SGX可以保护数据的处理过程，系统的状态信息。因此我们将DHT协议的处理过程放在Intel Enclave中进行。每个机器在启动的时候，都随机生成一个位置。因此，即是文件的key 和 hash function是公开的，但是机器与文件的对应关系依然是隐藏的。尽管如此，一个掌握系统所有I/O信息的攻击者还是可以猜到文件与机器的关系。
为了避免机器之间每次通信都需要用remote attestation，我们将PKI机制和remote attestation机制相结合。在部署集群时，设置一个CA。当集群中每个机器启动的时候，首先在Enclave中生成一个公私钥对PK,，以及对应的certificate 文件。而后向CA发送一个attestation，CA检验过server的attestation report之后，对Server的Certificate 文件进行签名。   
每个server在编程的时候，都需要将PKca hard  code在Enclave中，这样做可以避免server信任错误的机器，保证public key不会被替换。
每个机器上的程序分为两个部分，安全部分和非安全部分。由于安全部分不能直接操作IO，因此，非安全部分负责网络通信和磁盘读写。安全部分从内存中读出数据或写回。在实现中我们会描述，如何控制能够高效且安全的在安全部分和非安全部分进行交互。

Intel SGX并不是必须的技术，任何一种可以保护程序安全运行的技术都可以使用。只要能够保证敏感数据的处理是安全且不会被窥探。

#### User request
从高层次看，我们的系统是一个Key-value store。  用户的数据以Object的形式存储起来， 每个Object通过Key决定存储位置。远端的用户通过get(key), put(key, value)来获取文件。
每个用户在向服务器发送请求时，通过一个IP层的load-balance随机选择集群中的任意一台机器进行通信。 Client 中拥有PKca，每次和server的连接都采用标准的SSL通信流程：先协商同步秘钥，之后再使用该同步秘钥加密通信。因此每次请求都会使用不同的秘钥。与用户通信的机器收到用户的请求之后，成为一个代理delegation，通过key找到对应的机器，并请对应机器完成请求后返回给用户。 这个过程对于用户来说是透明的。
我们希望系统可以兼容已有的API，当Client简单地只是想要将数据安全的存储在云端，则通过像传统的对象存储系统一样的API工作。例如一个service provider 需要将存储的数据开放给公众用户使用时。因此对于用户来说，他信任CA，所以他可以不用在乎集群中的Intel SGX技术，只使用SSL进行通信。另一方面，用户使用SGX remote attestation可能会带来隐私的忧虑。[remoteinsuff]
在此，我们将用户请求，数据包，和网络包描述清楚。用户请求是指一个client 通过API发起一个对数据进行操作的请求。数据包是指，机器与机器之间通信时发送的加密数据。而网络包则是网络层的概念。  

###Threat Model（攻击者有什么能力，我们的目标是防止什么攻击）
我们假定攻击者物理上可以控制整个data center的机器。攻击者可以控制整个集群中程序的不安全部分，但是无法窥探到Enclave内部的数据，以及信息的处理过程。
因此，攻击者可以知道集群中每个机器每时每刻在和哪台机器通信，也知道哪些机器向哪个地方进行了存储。但是因为攻击者不知道机器之间通信的秘钥，因此无法得知机器通信的内容和存储的内容，同时也无法将一个数据包的目标机器改变——其他机器并不知道对应通信的秘钥。同时因为机器之间通信有一个nonce防止reply 攻击。
在我们的模型中，攻击者不但是好奇的，同时也是恶意的。
攻击者在长时间监测集群中所有的流量和I/O操作同时，也可以恶意的破坏集群中的某些机器，或者dos攻击部分机器：这些事情在系统中总是会发生，攻击者可以将他的恶意行为伪装成普通的系统错误。 攻击者可以控制集群，因此其可以简单的将Storage的应用程序杀死，或者拒绝为其处理I/O请求，甚至直接关机或者物理破坏机器。  
但是攻击者不能大规模的瘫痪集群或者大规模的DOS，这样会被发现。攻击者的所有active操作都要符合这一点。
除了针对机器之间的通信side channel，攻击者也许会对单机进行side channel攻击，例如通过memory access pattern猜出数据包发送的位置，因此我们也需要降低这种攻击发生的可能性。
我们不考虑攻击者无差别的删除文件----尽管这是slience的，但是我们保证攻击者不知道自己的文件是哪个，因此这样做对于攻击者来说并没有任何好处。
我们并不处理针对硬件本身的攻击，所有针对硬件攻击的防护均来自Intel SGX。Intel SGX技术本身只存在于CPU内部，而对于CPU内部本身的逆向工程和破解依然难以实现。

###Challenge(Why it's hard).
尽管我们将文件的处理过程都交给Intel SGX保护，但是一个更加强力的攻击者依然有很多方法可以找到文件对应的位置。
攻击者可以通过长时间的流量分析来找到文件可能的位置。尽管有副本存在，攻击者依然可能通过crash其中一个副本，再通过流量分析找到另外两个副本。[traffic analysis papers]
