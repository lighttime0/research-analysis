### 代码分析

#### 1、run_screen_freeze_test.py

##### （1）设置测试app的apk文件位置、测试过程生成的log文件存放位置、测试结果文件存放位置

```
    apk_top_folder = r'/home/ll/下载/pretect/apk'
    log_top_folder = r'/home/ll/下载/pretect/log'
    report_top_folder = r'/home/ll/下载/pretect/reports'
```

##### （2）不明白

```
    last_update_time = datetime.datetime(2016, 4, 5, 20, 30).timestamp()
```

##### （3）在apk_top_folder目录下建立一个json文件

```
    json_file = path.join(apk_top_folder, 'apk_to_package.json')
```

##### （4）利用pretect/code/deployment/deployment/screen_freeze_test/src/com/cudroid/utils目录下的apk_utils.py中的ApkUtil类
的静态方法apks_to_package获得apk路径和包名的映射关系，并记录在apk_to_package.json文件中

```
    ApkUtil.apks_to_package(apk_top_folder, json_file)
```

具体实现：建立一个空dict作为记录apk路径和包名的映射关系的结构，遍历apk_top_folder下的目录及文件，过滤出后缀为apk的apk_file，利用
os.path.join得到apk的完整路径，即apk_path。利用apk_path构建出一个ApkUtil类的实例对象，利用实例方法get_package_name获取package_name，
将apk路径和包名的映射关系记录在apk_package_map中，最后将该映射写到json_file中

```
    def apks_to_package(apk_top_folder, json_file_path):
        apk_package_map = dict()
        for root, dirs, files in os.walk(apk_top_folder):
            for apk_file in filter(lambda s: s.endswith(".apk"), files):
                apk_path = os.path.join(root, apk_file)
                package_name = ApkUtil(apk_path).get_package_name()
                apk_package_map[apk_path] = package_name

        with open(json_file_path, 'w') as json_file:
            json.dump(apk_package_map, json_file)
```
ApkUtil类的实例对象有两个成员变量，__apk_path由构造函数传入，通过get_package_name(self)方法获取package_name，如果
apks_to_package_map中已存在，可以直接通过self.__apk_path得到，否则，先利用_get_badging_strs_via_appt(self)函数获得_badging_strs，
实际上就是执行aapt dump badging <apk_path>命令，其值为apk包的packageName、versionCode、applicationLabel、launcherActivity、
permission等各种详细信息，最后通过查找得到package_name

```
    def __init__(self, apk_path):
        self.__apk_path = apk_path
        self._badging_strs = None

    def _get_badging_strs_via_appt(self):
        if not self._badging_strs:
            #command = "{aapt_exe} dump badging {apk_path}".format(aapt_exe='aapt.exe',
                                                                  #apk_path=self.__apk_path)
            command = "aapt dump badging {apk_path}".format(apk_path=self.__apk_path)
            temp_file = "temp.txt"
            command_utils.run_command(command, output=True, wait=True,
                                      outfile=temp_file)
            with open(temp_file, encoding=ENCODING) as file:
                self._badging_strs = file.readlines()
            os.remove(temp_file)
        return self._badging_strs

    def get_package_name(self):
        # if loaded
        package_name = self.apks_to_package_map.get(self.__apk_path)
        if package_name is not None: return package_name

        # not loaded
        badging_strs = self._get_badging_strs_via_appt()
        package_lines = list(filter(lambda s: "package: " in s, badging_strs))
        package_name = re.findall(r"name='([^']*)'", package_lines[0])[0] if package_lines else None
        return package_name

```
##### （5）利用ApkUtil的类方法load_apks_to_package加载json_file文件获取apk路径和包名的映射关系
```
    apkutils.ApkUtil.load_apks_to_package(json_file)
```
```
    def load_apks_to_package(cls, json_file_path):
        with open(json_file_path) as json_file:
            cls.apks_to_package_map = json.load(json_file)
```
##### （6）遍历apk_top_folder目录，获取apk文件的category、apk_path、log_folder、package_name、category_report_folder、report_folder
```
    for root, dirs, files in os.walk(apk_top_folder):
        for apk_file in filter(lambda s: s.endswith(".apk"), files):
            category = os.path.basename(root)
            apk_path = os.path.join(root, apk_file)
            log_folder = path.join(log_top_folder, category)
            package_name = apkutils.ApkUtil.get_package_with_path(apk_path, json_file)
            category_report_folder = path.join(report_top_folder, category)
            report_folder = path.join(category_report_folder, package_name)
```
##### （7）保存标准输出流，将一个文件对象“test_”赋给sys.stdout，可使随后的输出至该对象。如果report_folder已经生成且[bad]结果存在，则关闭到
文件的输出流，应将sys.stdout恢复最初的缺省值，即标准输出。
```
     temp = sys.stdout
     sys.stdout = open("test_" + time.strftime("%Y%m%d", time.localtime()) + '.out', 'a')

          
     if os.path.isdir(report_folder) and len(list(filter(lambda f: "bad_" in f, os.listdir(report_folder)))) > 0:
           #redirect stdout
           sys.stdout.close()
           sys.stdout = temp
           continue
```
##### （8）执行com.cudroid.perf_refresh.run_test的main方法开始测试
```
      run_test.main(apk_path, log_folder, category_report_folder, last_processed_time=last_update_time,
                          require_check_processed=True)
```
##### （9）关闭到文件的输出流，应将sys.stdout恢复最初的缺省值，即标准输出。
```
      # redirect stdout
      sys.stdout.close()
      sys.stdout = temp
```
##### （9）如果bad文件不存在则输出"[good]:"+report_folder目录，否则输出"[bad]:" + report_folder
```
      if not len(list(filter(lambda f: "bad_" in f, os.listdir(report_folder)))) > 0:
            print("[good]:" + report_folder)
      else:
            print("[bad]:" + report_folder)
```
